<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Free Final Frame Extractor for AI Videos | Lastframe.video</title>
  <meta name="description" content="Final frame tool by Lastframe.video. Upload a video, extract the last 5 frames, and download any frame instantly. Free online video frame extractor for US and UK creators." />
  <meta name="robots" content="index,follow" />
  <meta name="google-site-verification" content="YQq64Ykz4nzlywy-98VAQxPX1CqijcxPL8ODiZ4Eqrc" />
  <link rel="canonical" href="https://finalframe.video/" />
  <meta name="keywords" content="final frame, final frame extractor, finalframe, last frame extractor, extract last frame of video, get last frame of video, video frame extractor, extract frames from video, extract frame from video, video to frames, video frame grabber, frame extractor from video, frame downloader, mp4 frame extractor, video frame downloader, save video frame, frame capture, frame extraction, extract frames from video online, get frames from video, capture frame from video, frame by frame capture, save video frame by frame, ai video start and end frame, first frame to last frame ai" />

  <meta property="og:title" content="Final Frame - Free Video Frame Extractor" />
  <meta property="og:description" content="Upload video, get last 5 frames, and download in one click. Fast browser-based frame extraction." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://finalframe.video/" />
  <meta property="og:site_name" content="Lastframe.video" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Final Frame - Lastframe.video" />
  <meta name="twitter:description" content="Free video frame extractor: upload video, extract last 5 frames, download any frame." />

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-WZ6MPFBFBW"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-WZ6MPFBFBW');
  </script>

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    window.FRAME_EXTRACT_API_BASE = "https://lastframe-extractor-api.onrender.com";

    tailwind.config = {
      theme: {
        extend: {
          colors: {
            ink: "#161237",
            violet: {
              50: "#f5f1ff",
              100: "#ebe3ff",
              200: "#dacbff",
              300: "#bfa7ff",
              400: "#9c77ff",
              500: "#7a48ff",
              600: "#642ef4",
              700: "#5420db",
              800: "#471eb0"
            }
          },
          boxShadow: {
            glow: "0 20px 45px rgba(83, 35, 209, 0.2)"
          }
        }
      }
    };
  </script>

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@graph": [
      {
        "@type": "WebSite",
        "name": "Lastframe.video",
        "url": "https://finalframe.video/"
      },
      {
        "@type": "SoftwareApplication",
        "name": "Final Frame",
        "applicationCategory": "MultimediaApplication",
        "operatingSystem": "Web",
        "url": "https://finalframe.video/",
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "USD"
        },
        "description": "Free online video frame extractor to capture and download the last frames from uploaded videos."
      },
      {
        "@type": "FAQPage",
        "mainEntity": [
          {
            "@type": "Question",
            "name": "How do I extract the final frame from a video without editing software?",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "Upload your file, wait for the final five frames to be generated, and click the one you want. The frame is downloaded as a PNG image for immediate use."
            }
          },
          {
            "@type": "Question",
            "name": "Is Lastframe.video free for final frame extraction?",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "Yes. The tool is free and optimized for fast final-frame workflows."
            }
          },
          {
            "@type": "Question",
            "name": "Does this work for MP4 and WebM?",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "Yes in most cases, as long as the browser supports the codec in the source file."
            }
          },
          {
            "@type": "Question",
            "name": "Can I use this as a video frame grabber or video frame downloader?",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "Yes. This tool behaves like a video frame grabber for the final sequence and lets you download selected frames as PNG images."
            }
          },
          {
            "@type": "Question",
            "name": "How is this different from extract frames from video online tools?",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "Many tools export every frame from the full timeline. Lastframe.video focuses on the last frames so you can move faster when your goal is final shot selection or continuity."
            }
          },
          {
            "@type": "Question",
            "name": "Can this help with AI video start and end frame workflows?",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "Yes. Teams often reuse the last frame from one clip as a reference to start the next generated clip and maintain style continuity."
            }
          },
          {
            "@type": "Question",
            "name": "Can I capture frame from video on mobile browsers?",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "Usually yes on modern devices, provided the browser supports the uploaded format and codec."
            }
          },
          {
            "@type": "Question",
            "name": "Does this support video URL to frames conversion?",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "No. This version works with local file upload. URL ingestion can be added later as a separate feature."
            }
          }
        ]
      }
    ]
  }
  </script>

  <style>
    .page-bg {
      background:
        radial-gradient(900px 400px at 8% -8%, rgba(125, 72, 255, 0.24), transparent 55%),
        radial-gradient(800px 380px at 100% 0, rgba(210, 189, 255, 0.35), transparent 60%),
        #f7f4ff;
    }

    .frame-card {
      border: 1px solid #dacbff;
      background: #fff;
      border-radius: 12px;
      padding: 8px;
      text-align: left;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .frame-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(84, 32, 219, 0.12);
    }

    .frame-thumb {
      display: block;
      width: 100%;
      border-radius: 10px;
      border: 1px solid #ebe3ff;
      background: #f5f1ff;
    }

    .frame-meta {
      margin-top: 8px;
      font-size: 12px;
      font-weight: 700;
      color: #3c2f7a;
    }

    .skeleton-thumb {
      height: 120px;
      width: 100%;
      border-radius: 10px;
      border: 1px solid #ebe3ff;
      background: linear-gradient(90deg, #e9e0ff 20%, #f6f1ff 40%, #e9e0ff 60%);
      background-size: 200% 100%;
      animation: shimmer 1.2s linear infinite;
    }

    .skeleton-line {
      margin-top: 8px;
      height: 12px;
      width: 62%;
      border-radius: 999px;
      background: linear-gradient(90deg, #e9e0ff 20%, #f6f1ff 40%, #e9e0ff 60%);
      background-size: 200% 100%;
      animation: shimmer 1.2s linear infinite;
    }

    @keyframes shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
  </style>
</head>
<body class="page-bg text-ink antialiased">
  <div class="mx-auto my-4 max-w-[1280px] rounded-3xl border border-violet-200 bg-white shadow-glow">
    <section class="min-h-screen rounded-3xl bg-gradient-to-b from-violet-50 via-white to-white px-6 py-6 md:px-10">
      <header class="flex flex-wrap items-center justify-between gap-4">
        <a href="#top" class="inline-flex items-center gap-3 font-extrabold tracking-wide text-ink">
          <span class="grid h-10 w-10 place-items-center rounded-xl bg-gradient-to-br from-violet-500 to-violet-700 text-lg text-white shadow-md">L</span>
          <span>LASTFRAME.VIDEO</span>
        </a>
        <nav class="hidden items-center gap-6 text-sm font-semibold text-violet-800 md:flex">
          <a href="#extractor" class="hover:text-violet-600">Extractor</a>
          <a href="#use-cases" class="hover:text-violet-600">Use Cases</a>
          <a href="#faq" class="hover:text-violet-600">FAQs</a>
        </nav>
        <a href="#extractor" class="rounded-full border border-violet-300 bg-white px-5 py-2.5 text-sm font-bold text-violet-800 transition hover:border-violet-500 hover:text-violet-600">Open Tool</a>
      </header>

      <div id="top" class="mx-auto mt-14 max-w-5xl text-center md:mt-16">
        <p class="text-sm font-bold uppercase tracking-[0.22em] text-violet-700">Final Frame Extractor</p>
        <h1 class="mt-4 text-4xl font-black leading-tight text-ink sm:text-5xl md:text-7xl">
          Extract Your
          <span class="text-violet-600">Last 5 Frames</span>
        </h1>
        <p class="mx-auto mt-6 max-w-2xl text-lg text-violet-900/75 md:text-xl">
          A fast, browser-based video frame extractor for creators who need the final frame for continuity, thumbnails, and AI video start-end workflows.
        </p>

        <div id="extractor" class="mx-auto mt-8 rounded-2xl border border-violet-200 bg-white p-5 text-left shadow-sm md:p-7">
          <p class="text-base text-violet-800/80 md:text-lg">Upload a video file to generate the last five frames. Click any thumbnail to download as PNG.</p>
          <div class="mt-4 rounded-2xl border-2 border-dashed border-violet-300 bg-violet-50 p-4 md:p-6">
            <label for="videoInput" class="text-4xl font-black leading-tight text-ink md:text-5xl">Select a video file</label>
            <input id="videoInput" type="file" accept="video/*,.mp4,.mov,.mkv,.webm,.avi,.mpeg,.mpg,.m4v,.3gp,.ogv,.wmv" class="mt-4 block w-full rounded-lg border border-violet-200 bg-white p-2.5 text-sm text-violet-900 file:mr-4 file:rounded-md file:border-0 file:bg-violet-600 file:px-4 file:py-2 file:font-semibold file:text-white hover:file:bg-violet-700" />
            <p class="mt-3 text-sm text-violet-900/70">Best results with MP4 (H.264/AAC) or WebM. Browser decoding support varies by codec and device.</p>
          </div>

          <div class="mt-4 flex justify-center">
            <label for="videoInput" class="inline-flex cursor-pointer items-center rounded-full bg-violet-600 px-8 py-3 text-sm font-bold text-white shadow-lg shadow-violet-500/30 transition hover:bg-violet-700">Upload Video</label>
          </div>
        </div>

        <div id="processingLoader" class="mx-auto mt-3 hidden max-w-4xl items-center gap-3 rounded-xl border border-violet-200 bg-violet-50 px-4 py-3 text-left text-sm font-semibold text-violet-800">
          <span class="inline-block h-4 w-4 animate-spin rounded-full border-2 border-violet-300 border-t-violet-700"></span>
          <span id="processingText">Processing video...</span>
        </div>

        <div id="status" class="mx-auto mt-4 min-h-[1.5rem] max-w-4xl text-left text-sm font-bold text-violet-700" aria-live="polite"></div>
        <div id="frames" class="mx-auto mt-4 grid max-w-5xl gap-3 text-left sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5"></div>

        <div class="mt-8 flex flex-wrap items-center justify-center gap-2 text-xs font-semibold text-violet-800/85">
          <span class="rounded-full border border-violet-200 bg-violet-50 px-3 py-1.5">MP4</span>
          <span class="rounded-full border border-violet-200 bg-violet-50 px-3 py-1.5">WebM</span>
          <span class="rounded-full border border-violet-200 bg-violet-50 px-3 py-1.5">PNG Download</span>
          <span class="rounded-full border border-violet-200 bg-violet-50 px-3 py-1.5">Browser First</span>
        </div>
      </div>
    </section>

    <main class="space-y-4 bg-violet-50/50 px-4 pb-8 pt-4 md:px-10">
      <section id="use-cases" class="grid gap-4 md:grid-cols-2">
        <article class="rounded-2xl border border-violet-200 bg-white p-6">
          <h2 class="text-2xl font-black text-ink">When to use this tool</h2>
          <p class="mt-3 text-violet-900/75">This tool is ideal when you need the ending visual from a clip without opening a heavy editor. It is useful for continuity checks, quick approvals, and final-frame handoff into the next creative step.</p>
          <p class="mt-3 text-violet-900/75">Many teams use the last frame from one clip as a reference for the next generated shot, especially in AI workflows where visual consistency matters.</p>
        </article>

        <article class="rounded-2xl border border-violet-200 bg-white p-6">
          <h2 class="text-2xl font-black text-ink">Popular use cases</h2>
          <p class="mt-3 text-violet-900/75">Use extracted frames for thumbnail testing, storyboard references, presentation decks, or as a frame downloader for social assets. The final five-frame view gives better selection control than a single auto-captured still.</p>
          <p class="mt-3 text-violet-900/75">It is also practical for rapid export-review loops where speed and visual continuity are both important.</p>
        </article>
      </section>

      <section id="faq" class="rounded-2xl border border-violet-200 bg-white p-6">
        <h2 class="text-2xl font-black text-ink">FAQ</h2>

        <div class="mt-4 space-y-5 text-violet-900/80">
          <div>
            <h3 class="text-lg font-extrabold text-ink">How do I extract the final frame from a video without editing software?</h3>
            <p class="mt-1">Upload your video, wait for the final five frames, and click the frame you want. It downloads as PNG for immediate use.</p>
          </div>
          <div>
            <h3 class="text-lg font-extrabold text-ink">Is Lastframe.video free for final frame extraction?</h3>
            <p class="mt-1">Yes. The tool is free and optimized for fast final-frame extraction and download.</p>
          </div>
          <div>
            <h3 class="text-lg font-extrabold text-ink">Does this work with MP4 and WebM?</h3>
            <p class="mt-1">In most cases yes, as long as your browser supports the codec in the uploaded file.</p>
          </div>
          <div>
            <h3 class="text-lg font-extrabold text-ink">Are videos uploaded to a server?</h3>
            <p class="mt-1">Usually no. Extraction runs in your browser first, and only falls back to server extraction if your codec is unsupported.</p>
          </div>
          <div>
            <h3 class="text-lg font-extrabold text-ink">Can I use this as a video frame grabber or video frame downloader?</h3>
            <p class="mt-1">Yes. It works as a focused frame grabber for the end of your clip and allows one-click PNG download for each extracted frame.</p>
          </div>
          <div>
            <h3 class="text-lg font-extrabold text-ink">How is this different from full video to frames tools?</h3>
            <p class="mt-1">Full extraction tools process entire timelines. This tool is intentionally optimized for final-frame extraction, which is faster when you only need the ending sequence.</p>
          </div>
          <div>
            <h3 class="text-lg font-extrabold text-ink">Can this support AI start frame and end frame continuity?</h3>
            <p class="mt-1">Yes. Many creators use the last frame from one generation as the first reference for the next clip to reduce abrupt transitions and keep composition stable.</p>
          </div>
          <div>
            <h3 class="text-lg font-extrabold text-ink">Is this useful for save video frame, frame capture, and frame extraction tasks?</h3>
            <p class="mt-1">Yes. Whether you call it frame capture, frame extraction, or save video frame workflow, the output is a downloadable PNG that can be reused in edits, decks, or prompts.</p>
          </div>
          <div>
            <h3 class="text-lg font-extrabold text-ink">Can I get frames from video on mobile?</h3>
            <p class="mt-1">Usually yes, as long as the uploaded file codec is supported by your mobile browser. MP4 and WebM generally provide the best compatibility.</p>
          </div>
          <div>
            <h3 class="text-lg font-extrabold text-ink">Does this support video URL to frames?</h3>
            <p class="mt-1">Not in this version. You currently upload a local file from device storage for faster and simpler browser-side processing.</p>
          </div>
        </div>
      </section>
    </main>

    <footer class="px-6 pb-8 text-center text-sm font-medium text-violet-900/70 md:px-10">
      Lastframe.video: free final frame extractor and video frame downloader for creators in the US, UK, and globally.
    </footer>
  </div>

  <video id="video" class="absolute left-[-9999px] h-px w-px opacity-0 pointer-events-none" preload="metadata" muted playsinline></video>
  <canvas id="canvas" class="hidden"></canvas>

  <script>
    const videoInput = document.getElementById("videoInput");
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const framesEl = document.getElementById("frames");
    const statusEl = document.getElementById("status");
    const processingLoaderEl = document.getElementById("processingLoader");
    const processingTextEl = document.getElementById("processingText");
    const FRAME_EXTRACT_API_BASE = (window.FRAME_EXTRACT_API_BASE || "").trim().replace(/\/+$/, "");

    let currentObjectUrl = null;

    function setStatus(message) {
      statusEl.textContent = message;
    }

    function setLoading(isLoading, message = "Processing video...") {
      if (isLoading) {
        processingTextEl.textContent = message;
        processingLoaderEl.classList.remove("hidden");
        processingLoaderEl.classList.add("flex");
        videoInput.disabled = true;
        videoInput.classList.add("opacity-70", "cursor-not-allowed");
      } else {
        processingLoaderEl.classList.add("hidden");
        processingLoaderEl.classList.remove("flex");
        videoInput.disabled = false;
        videoInput.classList.remove("opacity-70", "cursor-not-allowed");
      }
    }

    function waitForEvent(target, eventName) {
      return new Promise((resolve, reject) => {
        const onOk = () => {
          cleanup();
          resolve();
        };

        const onErr = () => {
          cleanup();
          reject(new Error(`Failed while waiting for ${eventName}`));
        };

        const cleanup = () => {
          target.removeEventListener(eventName, onOk);
          target.removeEventListener("error", onErr);
        };

        target.addEventListener(eventName, onOk, { once: true });
        target.addEventListener("error", onErr, { once: true });
      });
    }

    async function seekTo(timeInSeconds) {
      if (!Number.isFinite(timeInSeconds)) {
        throw new Error("Invalid seek time.");
      }

      const safeTime = Math.max(0, Math.min(timeInSeconds, Math.max(video.duration - 0.001, 0)));
      const seeked = waitForEvent(video, "seeked");
      video.currentTime = safeTime;
      await seeked;
    }

    function drawCurrentFrame() {
      const width = video.videoWidth;
      const height = video.videoHeight;
      if (!width || !height) {
        throw new Error("Could not read video frame size.");
      }

      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(video, 0, 0, width, height);
      return canvas.toDataURL("image/png");
    }

    function downloadDataUrl(dataUrl, filename) {
      const link = document.createElement("a");
      link.href = dataUrl;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      link.remove();
    }

    function extensionFromDataUrl(dataUrl) {
      if (typeof dataUrl !== "string") return "png";
      if (dataUrl.startsWith("data:image/jpeg")) return "jpg";
      if (dataUrl.startsWith("data:image/webp")) return "webp";
      return "png";
    }

    function renderFrames(frames) {
      framesEl.innerHTML = "";
      frames.forEach((frame, idx) => {
        const btn = document.createElement("button");
        btn.className = "frame-card";
        btn.type = "button";
        btn.setAttribute("aria-label", `Download frame ${idx + 1}`);

        btn.innerHTML = `
          <img src="${frame.dataUrl}" alt="Video frame at ${frame.timeLabel}" class="frame-thumb" />
          <div class="frame-meta">${frame.timeLabel} (click to download)</div>
        `;

        btn.addEventListener("click", () => {
          const ext = extensionFromDataUrl(frame.dataUrl);
          downloadDataUrl(frame.dataUrl, `video-frame-${idx + 1}.${ext}`);
        });

        framesEl.appendChild(btn);
      });
    }

    function renderFrameSkeletons(count = 5) {
      framesEl.innerHTML = "";
      for (let i = 0; i < count; i += 1) {
        const card = document.createElement("div");
        card.className = "frame-card";
        card.innerHTML = `
          <div class="skeleton-thumb"></div>
          <div class="skeleton-line"></div>
        `;
        framesEl.appendChild(card);
      }
    }

    function buildLastFiveTimes(duration) {
      const count = 5;
      const epsilon = 0.03;
      const total = Math.max(duration - epsilon, 0);
      const start = Math.max(total - 2, 0);
      const step = count === 1 ? 0 : (total - start) / (count - 1);

      return Array.from({ length: count }, (_, i) => {
        const t = start + i * step;
        return Math.max(0, Math.min(t, total));
      });
    }

    function formatTime(seconds) {
      const s = Math.max(0, Math.floor(seconds));
      const mins = Math.floor(s / 60);
      const rem = s % 60;
      return `${mins}:${String(rem).padStart(2, "0")}`;
    }

    async function wakeExtractionServer() {
      if (!FRAME_EXTRACT_API_BASE) return;
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 45000);
      try {
        await fetch(`${FRAME_EXTRACT_API_BASE}/health`, { method: "GET", signal: controller.signal });
      } catch (err) {
        // Best-effort warm-up only.
      } finally {
        clearTimeout(timeout);
      }
    }

    async function processVideoViaApi(file) {
      const formData = new FormData();
      formData.append("video", file);

      setStatus("Preparing server extraction fallback...");
      setLoading(true, "Preparing server extraction...");
      renderFrameSkeletons(5);

      const runApiCall = async () => {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 300000);
        try {
          setStatus("Uploading video to extraction server...");
          setLoading(true, "Uploading and extracting...");

          const response = await fetch(`${FRAME_EXTRACT_API_BASE}/api/extract-last-frames`, {
            method: "POST",
            body: formData,
            signal: controller.signal
          });

          const payload = await response.json().catch(() => ({}));
          if (!response.ok) {
            const detail = payload && payload.detail ? payload.detail : "Server extraction failed.";
            throw new Error(detail);
          }

          const frames = (payload.frames || []).map((f, idx) => ({
            dataUrl: f.data_url,
            timeLabel: f.time_label || formatTime(f.time_seconds || idx)
          }));

          if (!frames.length) {
            throw new Error("No frames returned by extraction server.");
          }

          return frames;
        } finally {
          clearTimeout(timeout);
        }
      };

      try {
        let frames;
        try {
          frames = await runApiCall();
        } catch (firstErr) {
          setStatus("Server is starting up. Retrying extraction...");
          setLoading(true, "Retrying extraction...");
          await wakeExtractionServer();
          frames = await runApiCall();
        }

        renderFrames(frames);
        setStatus("Done. Click any frame to download.");
      } catch (err) {
        console.error(err);
        framesEl.innerHTML = "";
        throw err;
      } finally {
        setLoading(false);
      }
    }

    async function processVideoInBrowser(file, options = {}) {
      const throwOnFailure = Boolean(options.throwOnFailure);
      if (!file) return;

      if (currentObjectUrl) {
        URL.revokeObjectURL(currentObjectUrl);
      }

      framesEl.innerHTML = "";
      setStatus("Loading video...");
      setLoading(true, "Loading and validating video...");
      renderFrameSkeletons(5);

      currentObjectUrl = URL.createObjectURL(file);
      video.src = currentObjectUrl;

      try {
        if (file.type && video.canPlayType(file.type) === "") {
          setStatus("This format may not be fully supported by your browser. Trying to extract frames anyway...");
        }

        await waitForEvent(video, "loadedmetadata");

        if (!Number.isFinite(video.duration) || video.duration <= 0) {
          throw new Error("Unsupported video or empty duration.");
        }

        const times = buildLastFiveTimes(video.duration);
        const frames = [];

        setStatus("Extracting last 5 frames...");
        setLoading(true, "Extracting final frames...");
        renderFrameSkeletons(5);

        for (let i = 0; i < times.length; i += 1) {
          await seekTo(times[i]);
          const dataUrl = drawCurrentFrame();
          frames.push({
            dataUrl,
            timeLabel: formatTime(times[i])
          });
        }

        renderFrames(frames);
        setStatus("Done. Click any frame to download.");
        setLoading(false);
      } catch (err) {
        console.error(err);
        setLoading(false);
        framesEl.innerHTML = "";
        setStatus("Browser extraction failed for this file. Trying server fallback...");
        if (throwOnFailure) {
          throw err;
        }
      } finally {
        setLoading(false);
      }
    }

    async function processVideo(file) {
      if (!file) return;
      try {
        await processVideoInBrowser(file, { throwOnFailure: true });
        return;
      } catch (browserErr) {
        if (!FRAME_EXTRACT_API_BASE) {
          setStatus("Could not decode this video in your browser. For best compatibility, convert to MP4 (H.264/AAC) and re-upload.");
          return;
        }
      }

      try {
        await processVideoViaApi(file);
      } catch (apiErr) {
        console.error(apiErr);
        framesEl.innerHTML = "";
        setStatus(`Server extraction failed: ${apiErr.message}. For best compatibility, convert to MP4 (H.264/AAC) and re-upload.`);
      }
    }

    videoInput.addEventListener("change", (event) => {
      const file = event.target.files && event.target.files[0];
      processVideo(file);
    });

  </script>
</body>
</html>
